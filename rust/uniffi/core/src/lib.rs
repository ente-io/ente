use base64::{
    engine::general_purpose::{STANDARD as BASE64_STANDARD, URL_SAFE as BASE64_URL_SAFE},
    Engine,
};
use once_cell::sync::Lazy;
use std::sync::{Mutex, MutexGuard};

use ente_core::{auth, crypto};

uniffi::include_scaffolding!("core");

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AuthSecrets {
    pub master_key: Vec<u8>,
    pub secret_key: Vec<u8>,
    pub token: Vec<u8>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct KeyAttributes {
    pub kek_salt: String,
    pub encrypted_key: String,
    pub key_decryption_nonce: String,
    pub public_key: String,
    pub encrypted_secret_key: String,
    pub secret_key_decryption_nonce: String,
    pub mem_limit: Option<u32>,
    pub ops_limit: Option<u32>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SrpAttributes {
    pub srp_user_id: String,
    pub srp_salt: String,
    pub kek_salt: String,
    pub mem_limit: u32,
    pub ops_limit: u32,
    pub is_email_mfa_enabled: bool,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SrpSessionResult {
    pub srp_a: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SrpVerifyResult {
    pub srp_m1: String,
}

#[derive(Debug, thiserror::Error)]
pub enum EnsuError {
    #[error("{reason}")]
    Message { reason: String },
}

impl From<auth::AuthError> for EnsuError {
    fn from(err: auth::AuthError) -> Self {
        EnsuError::Message {
            reason: err.to_string(),
        }
    }
}

struct SrpState {
    session: auth::SrpSession,
    kek: crypto::SecretVec,
}

static SRP_STATE: Lazy<Mutex<Option<SrpState>>> = Lazy::new(|| Mutex::new(None));

fn lock_srp_state() -> Result<MutexGuard<'static, Option<SrpState>>, EnsuError> {
    SRP_STATE.lock().map_err(|_| EnsuError::Message {
        reason: "SRP state lock poisoned".to_string(),
    })
}

fn to_core_key_attrs(attrs: &KeyAttributes) -> auth::KeyAttributes {
    auth::KeyAttributes {
        kek_salt: attrs.kek_salt.clone(),
        encrypted_key: attrs.encrypted_key.clone(),
        key_decryption_nonce: attrs.key_decryption_nonce.clone(),
        public_key: attrs.public_key.clone(),
        encrypted_secret_key: attrs.encrypted_secret_key.clone(),
        secret_key_decryption_nonce: attrs.secret_key_decryption_nonce.clone(),
        mem_limit: attrs.mem_limit,
        ops_limit: attrs.ops_limit,
        master_key_encrypted_with_recovery_key: None,
        master_key_decryption_nonce: None,
        recovery_key_encrypted_with_master_key: None,
        recovery_key_decryption_nonce: None,
    }
}

fn to_core_srp_attrs(attrs: &SrpAttributes) -> auth::SrpAttributes {
    auth::SrpAttributes {
        srp_user_id: attrs.srp_user_id.clone(),
        srp_salt: attrs.srp_salt.clone(),
        mem_limit: attrs.mem_limit,
        ops_limit: attrs.ops_limit,
        kek_salt: attrs.kek_salt.clone(),
        is_email_mfa_enabled: attrs.is_email_mfa_enabled,
    }
}

fn secrets_from_login_result(result: auth::LoginResult) -> AuthSecrets {
    AuthSecrets {
        master_key: result.master_key,
        secret_key: result.secret_key,
        token: result.token,
    }
}

fn secrets_from_decrypted(result: auth::DecryptedSecrets) -> AuthSecrets {
    AuthSecrets {
        master_key: result.master_key,
        secret_key: result.secret_key,
        token: result.token,
    }
}

fn decode_token(token: &str) -> Result<Vec<u8>, EnsuError> {
    // Tokens are generated by the server as base64 URL-safe with padding
    // (Go's base64.URLEncoding). Older tokens might still be standard base64.
    BASE64_URL_SAFE
        .decode(token)
        .or_else(|_| BASE64_STANDARD.decode(token))
        .map_err(|e| EnsuError::Message {
            reason: format!("token: {}", e),
        })
}

pub fn init_crypto() -> Result<(), EnsuError> {
    crypto::init().map_err(|e| EnsuError::Message {
        reason: e.to_string(),
    })
}

pub fn srp_start(
    password: String,
    srp_attrs: SrpAttributes,
) -> Result<SrpSessionResult, EnsuError> {
    let srp_attrs_core = to_core_srp_attrs(&srp_attrs);
    let creds = auth::derive_srp_credentials(&password, &srp_attrs_core)?;

    let srp_salt = crypto::decode_b64(&srp_attrs.srp_salt).map_err(|e| EnsuError::Message {
        reason: format!("srp_salt: {}", e),
    })?;

    let session = auth::SrpSession::new(&srp_attrs.srp_user_id, &srp_salt, &creds.login_key)?;
    let srp_a = crypto::encode_b64(&session.public_a());

    let mut guard = lock_srp_state()?;
    if guard.is_some() {
        return Err(EnsuError::Message {
            reason:
                "SRP session already initialized. Call srp_clear() before starting a new session"
                    .to_string(),
        });
    }

    *guard = Some(SrpState {
        session,
        kek: crypto::SecretVec::new(creds.kek),
    });

    Ok(SrpSessionResult { srp_a })
}

pub fn srp_finish(srp_b: String) -> Result<SrpVerifyResult, EnsuError> {
    let mut guard = lock_srp_state()?;
    let state = guard.as_mut().ok_or_else(|| EnsuError::Message {
        reason: "SRP session not initialized".to_string(),
    })?;

    let srp_b_bytes = crypto::decode_b64(&srp_b).map_err(|e| EnsuError::Message {
        reason: format!("srp_b: {}", e),
    })?;

    let srp_m1 = state.session.compute_m1(&srp_b_bytes)?;
    let srp_m1 = crypto::encode_b64(&srp_m1);

    Ok(SrpVerifyResult { srp_m1 })
}

pub fn srp_clear() {
    // Best-effort cleanup. Even if the lock is poisoned, we should avoid panicking.
    match SRP_STATE.lock() {
        Ok(mut guard) => {
            *guard = None;
        }
        Err(poisoned) => {
            let mut guard = poisoned.into_inner();
            *guard = None;
        }
    }
}

pub fn srp_decrypt_secrets(
    key_attrs: KeyAttributes,
    encrypted_token: Option<String>,
    plain_token: Option<String>,
) -> Result<AuthSecrets, EnsuError> {
    // Consume the SRP state so KEK doesn't linger in memory if the caller forgets srp_clear().
    let state = {
        let mut guard = lock_srp_state()?;
        guard.take().ok_or_else(|| EnsuError::Message {
            reason: "SRP session not initialized".to_string(),
        })?
    };

    let core_attrs = to_core_key_attrs(&key_attrs);

    if let Some(token) = encrypted_token {
        let result = auth::decrypt_secrets(&state.kek, &core_attrs, &token)?;
        return Ok(secrets_from_decrypted(result));
    }

    if let Some(token) = plain_token {
        let (master_key, secret_key) = auth::decrypt_keys_only(&state.kek, &core_attrs)?;
        let token_bytes = decode_token(&token)?;
        return Ok(AuthSecrets {
            master_key,
            secret_key,
            token: token_bytes,
        });
    }

    Err(EnsuError::Message {
        reason: "Missing auth token".to_string(),
    })
}

pub fn derive_kek_for_login(
    password: String,
    kek_salt: String,
    mem_limit: u32,
    ops_limit: u32,
) -> Result<Vec<u8>, EnsuError> {
    let kek = auth::derive_kek(&password, &kek_salt, mem_limit, ops_limit)?;
    Ok(kek)
}

pub fn decrypt_secrets_with_kek(
    kek: Vec<u8>,
    key_attrs: KeyAttributes,
    encrypted_token: Option<String>,
    plain_token: Option<String>,
) -> Result<AuthSecrets, EnsuError> {
    let kek = crypto::SecretVec::new(kek);
    let core_attrs = to_core_key_attrs(&key_attrs);

    if let Some(token) = encrypted_token {
        let result = auth::decrypt_secrets_with_kek(&kek, &core_attrs, &token)?;
        return Ok(secrets_from_login_result(result));
    }

    if let Some(token) = plain_token {
        let (master_key, secret_key) = auth::decrypt_keys_only(&kek, &core_attrs)?;
        let token_bytes = decode_token(&token)?;
        return Ok(AuthSecrets {
            master_key,
            secret_key,
            token: token_bytes,
        });
    }

    Err(EnsuError::Message {
        reason: "Missing auth token".to_string(),
    })
}
