dictionary AuthSecrets {
  sequence<u8> master_key;
  sequence<u8> secret_key;
  sequence<u8> token;
};

dictionary KeyAttributes {
  string kek_salt;
  string encrypted_key;
  string key_decryption_nonce;
  string public_key;
  string encrypted_secret_key;
  string secret_key_decryption_nonce;
  u32? mem_limit;
  u32? ops_limit;
};

dictionary SrpAttributes {
  string srp_user_id;
  string srp_salt;
  string kek_salt;
  u32 mem_limit;
  u32 ops_limit;
  boolean is_email_mfa_enabled;
};

dictionary SrpSessionResult {
  string srp_a;
};

dictionary SrpVerifyResult {
  string srp_m1;
};

[Error]
interface EnsuError {
  Message(string reason);
};

namespace core {
  [Throws=EnsuError]
  void init_crypto();

  [Throws=EnsuError]
  SrpSessionResult srp_start(string password, SrpAttributes srp_attrs);

  [Throws=EnsuError]
  SrpVerifyResult srp_finish(string srp_b);

  void srp_clear();

  [Throws=EnsuError]
  AuthSecrets srp_decrypt_secrets(KeyAttributes key_attrs, string? encrypted_token, string? plain_token);

  [Throws=EnsuError]
  sequence<u8> derive_kek_for_login(string password, string kek_salt, u32 mem_limit, u32 ops_limit);

  [Throws=EnsuError]
  AuthSecrets decrypt_secrets_with_kek(sequence<u8> kek, KeyAttributes key_attrs, string? encrypted_token, string? plain_token);
};
